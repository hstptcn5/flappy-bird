<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flappy Mini (N√¢ng Cao)</title>
  <!-- Th∆∞ vi·ªán Tone.js cho hi·ªáu ·ª©ng √¢m thanh (SFX) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    /* 1. CSS C∆† B·∫¢N & PHONG C√ÅCH */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #222;
      color: #fff;
      /* D√πng font hi·ªán ƒë·∫°i, d·ªÖ ƒë·ªçc, ph√π h·ª£p v·ªõi Tailwind/Inter */
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden; /* Tr√°nh thanh cu·ªôn tr√™n mobile */
    }

    #game-container {
      position: relative;
      /* ƒê·∫£m b·∫£o responsive tr√™n mobile */
      width: 100%;
      max-width: 400px; 
      aspect-ratio: 4 / 6; /* Gi·ªØ t·ª∑ l·ªá canvas */
    }

    canvas {
      /* M·∫∑c ƒë·ªãnh, s·∫Ω ƒë∆∞·ª£c JS ghi ƒë√® b·∫±ng gradient ƒë·ªông */
      background: linear-gradient(#4eb5ff, #c0f5ff); 
      display: block;
      width: 100%; /* Chi·∫øm h·∫øt container */
      height: 100%;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.6); /* ƒê·ªï b√≥ng s√¢u h∆°n */
      cursor: pointer;
      transition: background 0.5s; /* Chuy·ªÉn ƒë·ªïi m√†u n·ªÅn m∆∞·ª£t m√† */
    }
    
    /* 2. OVERLAY V√Ä CH·ªÆ GI·ªÆA M√ÄN H√åNH */

    #score-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      font-size: 16px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 6px;
      background-color: rgba(0, 0, 0, 0.4);
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      white-space: nowrap;
      /* Responsive font size cho mobile */
      @media (max-width: 600px) {
        font-size: 14px;
        top: 8px;
        left: 8px;
      }
    }

    #center-text {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* Kh√¥ng ch·∫∑n click */
      text-align: center;
      padding: 16px;
      font-size: 24px;
      font-weight: 800;
      line-height: 1.4;
      color: #fff;
      text-shadow: 0 0 8px rgba(0,0,0,1), 0 0 2px #000;
    }

    /* 3. N√öT CH·ªåN THEME/SKIN */
    .settings-button {
        pointer-events: all; /* Cho ph√©p click */
        margin-top: 20px;
        padding: 8px 16px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        box-shadow: 0 4px #2980b9;
        transition: all 0.1s;
    }
    
    .settings-button:active {
        transform: translateY(2px);
        box-shadow: 0 2px #2980b9;
    }
    
    /* 4. MODAL SETTINGS */
    #settings-modal {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 10;
        border-radius: 12px;
        padding: 20px;
        display: none; /* B·∫Øt ƒë·∫ßu ·∫©n */
        flex-direction: column;
        align-items: center;
        overflow-y: auto;
    }

    .shop-section {
        margin-bottom: 25px;
        width: 100%;
        max-width: 350px;
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 10px;
        padding: 15px;
        background-color: rgba(255,255,255,0.1);
    }
    
    .shop-section h3 {
        font-size: 1.5em;
        margin-bottom: 15px;
        text-align: center;
        text-shadow: 0 0 3px #000;
    }

    .selection-grid {
        display: flex;
        justify-content: space-around;
        gap: 10px;
        flex-wrap: wrap;
    }

    .item-card {
        padding: 10px;
        border-radius: 8px;
        text-align: center;
        cursor: pointer;
        width: 80px;
        transition: transform 0.1s, box-shadow 0.1s;
        border: 2px solid transparent;
        opacity: 0.7;
    }

    .item-card.selected {
        border-color: #3498db;
        box-shadow: 0 0 10px #3498db;
        opacity: 1;
        transform: scale(1.05);
    }
    
    .item-preview {
        width: 40px;
        height: 40px;
        margin: 0 auto 5px;
        border-radius: 50%;
        border: 2px solid white;
    }
    
    .theme-preview {
        height: 40px;
        margin: 0 auto 5px;
        border-radius: 5px;
        background-color: #2ecc71; /* Fallback */
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Canvas s·∫Ω ƒë∆∞·ª£c JS ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc ƒë·ªÉ fit container -->
    <canvas id="game" width="400" height="600"></canvas>
    <div id="score-overlay"></div>
    <div id="center-text"></div>
    
    <!-- MODAL SETTINGS/SHOP -->
    <div id="settings-modal" style="display: none;">
        <h2 style="margin-bottom: 20px; font-size: 2em; color: gold;">C·ª¨A H√ÄNG & C√ÄI ƒê·∫∂T</h2>

        <!-- 1. CH·ªåN TRANG PH·ª§C (SKIN) -->
        <div class="shop-section">
            <h3>Ch·ªçn Trang Ph·ª•c Chim</h3>
            <div id="skin-grid" class="selection-grid">
                <!-- N·ªôi dung ƒë∆∞·ª£c ch√®n b·∫±ng JS -->
            </div>
        </div>

        <!-- 2. CH·ªåN CH·ª¶ ƒê·ªÄ (THEME) -->
        <div class="shop-section">
            <h3>Ch·ªçn Ch·ªß ƒê·ªÅ M√†n Ch∆°i</h3>
            <div id="theme-grid" class="selection-grid">
                <!-- N·ªôi dung ƒë∆∞·ª£c ch√®n b·∫±ng JS -->
            </div>
        </div>

        <button class="settings-button" onclick="closeSettingsModal()" style="margin-top: 30px; background-color: #e74c3c; box-shadow: 0 4px #c0392b;">ƒê√ìNG</button>
    </div>
  </div>

  <script>
    // ƒê·ªãnh nghƒ©a c√°c h·∫±ng s·ªë v√† l·∫•y DOM elements
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreOverlay = document.getElementById("score-overlay");
    const centerText = document.getElementById("center-text");
    const settingsModal = document.getElementById("settings-modal");
    const skinGrid = document.getElementById("skin-grid");
    const themeGrid = document.getElementById("theme-grid");


    let width = canvas.width;
    let height = canvas.height;

    // --- C·∫•u h√¨nh Trang ph·ª•c & Ch·ªß ƒë·ªÅ ---
    
    // ƒê·ªãnh nghƒ©a Theme
    const THEMES = {
        'classic': {
            name: 'C·ªï ƒêi·ªÉn', pipeColor: '#2ecc71', pipeCapColor: '#34495e',
            skyGradient: 'linear-gradient(#4eb5ff, #c0f5ff)',
            groundColor: '#3b2f1e', grassColor: '#5bba47',
        },
        'lava': {
            name: 'N√∫i L·ª≠a', pipeColor: '#e74c3c', pipeCapColor: '#c0392b',
            skyGradient: 'linear-gradient(#434343, #222)',
            groundColor: '#78350f', grassColor: '#f1c40f',
        },
        'snow': {
            name: 'Tuy·∫øt', pipeColor: '#bdc3c7', pipeCapColor: '#7f8c8d',
            skyGradient: 'linear-gradient(#ddeeff, #f8f8ff)',
            groundColor: '#fff', grassColor: '#ecf0f1',
        },
    };

    // ƒê·ªãnh nghƒ©a Skin
    const SKINS = {
        'yellow': { name: 'V√†ng', body: '#f1c40f', outline: '#e67e22', wing: '#e67e22' },
        'red': { name: 'ƒê·ªè', body: '#e74c3c', outline: '#c0392b', wing: '#c0392b' },
        'blue': { name: 'Xanh', body: '#3498db', outline: '#2980b9', wing: '#2980b9' },
    };

    let currentTheme = localStorage.getItem('flappyTheme') || 'classic';
    let currentSkin = localStorage.getItem('flappySkin') || 'yellow';
    
    // --- C·∫•u h√¨nh Game ---
    
    // Chim
    const BIRD_RADIUS = 14;
    const BIRD_X = width * 0.3;
    let birdY;
    let birdVelocity;
    let birdRotation; // G√≥c quay c·ªßa chim
    let wingFlapTimer = 0; // Th·ªùi gian ƒë·∫≠p c√°nh t·ª± ƒë·ªông
    let isFlapping = false; // ƒê√°nh d·∫•u v·ª´a nh·∫£y ƒë·ªÉ ƒë·∫≠p c√°nh m·∫°nh
    const GRAVITY = 0.35; 
    const JUMP_STRENGTH = -7.5; 
    const MAX_ROTATION = Math.PI / 4; 
    const ROTATION_SPEED = 0.1; 
    const FLAP_AMPLITUDE = 0.4; // ƒê·ªô l·ªõn g√≥c ƒë·∫≠p c√°nh
    const FLAP_FREQUENCY = 10; // T·ªëc ƒë·ªô ƒë·∫≠p c√°nh

    // ·ªêng (Dynamic Difficulty)
    const pipes = [];
    const PIPE_WIDTH = 70;
    const PIPE_INTERVAL = 1700; 
    
    // BASE VALUES
    const BASE_PIPE_SPEED = 2.4;
    const BASE_GAP_HEIGHT = 150;
    
    // Dynamic variables
    let pipeSpeed;
    let gapHeight;
    let difficultyLevel;
    const DIFFICULTY_SCORE_STEP = 5; // TƒÉng ƒë·ªô kh√≥ m·ªói 5 ƒëi·ªÉm

    let pipeSpawnTimer = 0;
    
    // Parallax background (ƒê√°m m√¢y)
    const clouds = [
      { x: 50, y: 100, size: 80, speed: 0.5 },
      { x: 200, y: 50, size: 120, speed: 0.7 },
      { x: 350, y: 150, size: 60, speed: 0.6 }
    ];
    
    // Hi·ªáu ·ª©ng
    let shakeIntensity = 0;
    let particles = [];
    const SHAKE_DECAY = 0.9;
    const SHAKE_MAX = 8;
    const PARTICLE_COUNT = 20;

    // Game state
    let gameState = "menu"; // "menu" | "playing" | "gameOver"
    let score = 0;
    let bestScore = 0;
    let lastTime = 0;
    
    // --- √ÇM THANH (SFX) ---
    let jumpSynth, scoreSynth, hitNoise;

    function initAudio() {
        if (typeof Tone !== 'undefined') {
            try {
                // Chim nh·∫£y: Ti·∫øng tr·ªëng/l·∫•y h∆°i
                jumpSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 1.5,
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.05, }
                }).toDestination();

                // Ghi ƒëi·ªÉm: Ti·∫øng Pluck nh·∫π
                scoreSynth = new Tone.PluckSynth({
                    attackNoise: 1,
                    dampening: 2000,
                    resonance: 0.9
                }).toDestination();

                // Va ch·∫°m: Ti·∫øng ·ªìn ng·∫Øn
                hitNoise = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0, }
                }).toDestination();
            } catch (e) {
                console.error("Tone.js initialization failed:", e);
            }
        }
    }

    function playJump() { if (jumpSynth) jumpSynth.triggerAttackRelease("C5", "16n"); }
    function playScore() { if (scoreSynth) scoreSynth.triggerAttackRelease("G4", 0.1); }
    function playHit() { if (hitNoise) hitNoise.triggerAttackRelease("4n"); }
    
    // --- C√ÅC H√ÄM X·ª¨ L√ù CH·ª¶ ƒê·ªÄ/TRANG PH·ª§C ---

    function applyTheme(themeKey) {
        currentTheme = themeKey;
        localStorage.setItem('flappyTheme', themeKey);
        // C·∫≠p nh·∫≠t background CSS ngay l·∫≠p t·ª©c
        canvas.style.background = THEMES[currentTheme].skyGradient;
        draw(); // Y√™u c·∫ßu v·∫Ω l·∫°i ƒë·ªÉ √°p d·ª•ng m√†u ·ªëng
        renderSettings();
    }

    function applySkin(skinKey) {
        currentSkin = skinKey;
        localStorage.setItem('flappySkin', skinKey);
        draw(); // Y√™u c·∫ßu v·∫Ω l·∫°i ƒë·ªÉ √°p d·ª•ng m√†u chim
        renderSettings();
    }
    
    // H√ÄM S·ª¨A L·ªñI: Nh·∫≠n event v√† ch·∫∑n Propagation ƒë·ªÉ kh√¥ng k√≠ch ho·∫°t startGame()
    function openSettingsModal(e) {
        if (e) {
            e.stopPropagation(); // CH·∫∂N click event truy·ªÅn xu·ªëng canvas
            e.preventDefault(); // NgƒÉn h√†nh vi m·∫∑c ƒë·ªãnh (nh∆∞ g·ª≠i form, v.v.)
        }
        if (gameState === "playing") return;
        settingsModal.style.display = 'flex';
        renderSettings();
        // C·∫≠p nh·∫≠t l·∫°i UI sau khi m·ªü modal ƒë·ªÉ ƒë·∫£m b·∫£o n√∫t b·∫•m kh√¥ng b·ªã t·∫°o l·∫°i
        updateUIState();
    }

    function closeSettingsModal() {
        settingsModal.style.display = 'none';
        // C·∫≠p nh·∫≠t l·∫°i UI sau khi ƒë√≥ng modal
        updateUIState();
    }

    function renderSettings() {
        // Render Skins
        skinGrid.innerHTML = Object.keys(SKINS).map(key => {
            const skin = SKINS[key];
            const isSelected = key === currentSkin;
            return `
                <div class="item-card ${isSelected ? 'selected' : ''}" onclick="applySkin('${key}')">
                    <div class="item-preview" style="background-color: ${skin.body}; border-color: ${skin.outline};"></div>
                    <span>${skin.name}</span>
                </div>
            `;
        }).join('');

        // Render Themes
        themeGrid.innerHTML = Object.keys(THEMES).map(key => {
            const theme = THEMES[key];
            const isSelected = key === currentTheme;
            return `
                <div class="item-card ${isSelected ? 'selected' : ''}" onclick="applyTheme('${key}')">
                    <div class="theme-preview" style="background: ${theme.skyGradient}; border-color: ${theme.groundColor}; border: 3px solid ${theme.pipeColor};"></div>
                    <span>${theme.name}</span>
                </div>
            `;
        }).join('');
    }

    
    // --- Logic Game ---

    function resetGame() {
      // ƒê·∫∑t chim ·ªü gi·ªØa chi·ªÅu cao
      birdY = height / 2;
      birdVelocity = 0;
      birdRotation = 0; 
      wingFlapTimer = 0;

      // X√≥a ·ªëng
      pipes.length = 0;
      pipeSpawnTimer = 0;

      // Reset ƒëi·ªÉm
      score = 0;
      
      // Reset ƒë·ªô kh√≥
      pipeSpeed = BASE_PIPE_SPEED;
      gapHeight = BASE_GAP_HEIGHT;
      difficultyLevel = 0;
      
      // Reset hi·ªáu ·ª©ng
      shakeIntensity = 0;
      particles.length = 0;
      
      // Kh·ªüi t·∫°o l·∫°i k√≠ch th∆∞·ªõc canvas (ƒë·ªÉ x·ª≠ l√Ω responsive)
      resizeCanvas();
    }

    function startGame() {
      // C·∫ßn k√≠ch ho·∫°t Tone.js b·∫±ng m·ªôt h√†nh ƒë·ªông c·ªßa ng∆∞·ªùi d√πng
      if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
        Tone.start().then(() => {
            performStartGame();
        }).catch(e => {
            console.error("Could not start audio context:", e);
            performStartGame(); // V·∫´n ch·∫°y game d√π kh√¥ng c√≥ audio
        });
      } else {
        performStartGame();
      }
    }
    
    function performStartGame() {
        closeSettingsModal(); // ƒê√≥ng modal n·∫øu ƒëang m·ªü
        resetGame();
        gameState = "playing";
        // C·∫≠p nh·∫≠t UI ngay sau khi chuy·ªÉn tr·∫°ng th√°i
        updateUIState(); 
    }


    function gameOver() {
      gameState = "gameOver";
      playHit(); // Ch∆°i √¢m thanh va ch·∫°m
      shakeIntensity = SHAKE_MAX; // B·∫Øt ƒë·∫ßu rung m√†n h√¨nh
      createExplosion(BIRD_X, birdY); // T·∫°o h·∫°t b·ª•i

      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('flappyBestScore', bestScore);
      }
      
      // C·∫≠p nh·∫≠t UI ngay sau khi chuy·ªÉn tr·∫°ng th√°i
      updateUIState();
    }
    
    // H√†m qu·∫£n l√Ω tr·∫°ng th√°i UI (thay v√¨ l√†m trong Draw)
    function updateUIState() {
        if (settingsModal.style.display === 'flex') {
            // N·∫øu modal ƒëang m·ªü, kh√¥ng hi·ªÉn th·ªã center text
            centerText.innerHTML = '';
            return;
        }

        const settingsButtonHTML = 
            `<button class="settings-button" onclick="openSettingsModal(event)">T√πy Ch·ªânh Trang Ph·ª•c (B)</button>`;
        
        if (gameState === "menu") {
            centerText.innerHTML =
                `FLAPPY MINI<br/>
                <span style="font-size: 0.8em; font-weight: 500;">(ƒê·ªì √°n nh·ªè)</span><br/><br/>` +
                `<span style="font-size: 1.1em;">B·∫•m <b>Space</b> ho·∫∑c <b>Click/Touch</b> ƒë·ªÉ b·∫Øt ƒë·∫ßu</span>` +
                settingsButtonHTML;
        } else if (gameState === "gameOver") {
            // H·ªá th·ªëng Huy ch∆∞∆°ng (Medal System)
            let medal = "";
            if (score >= 40) {
                medal = "<span style='color: #4dc2ff;'><b>HUY CH∆Ø∆†NG KIM C∆Ø∆†NG</b> üíé</span>";
            } else if (score >= 30) {
                medal = "<span style='color: gold;'><b>HUY CH∆Ø∆†NG V√ÄNG</b> ü•á</span>";
            } else if (score >= 20) {
                medal = "<span style='color: silver;'><b>HUY CH∆Ø∆†NG B·∫†C</b> ü•à</span>";
            } else if (score >= 10) {
                medal = "<span style='color: #cd7f32;'><b>HUY CH∆Ø∆†NG ƒê·ªíNG</b> ü•â</span>";
            }

            centerText.innerHTML =
                `GAME OVER<br/>
                <span style="font-size: 1.1em;">${medal}</span><br/>
                <span style="font-size: 1.2em;">ƒêi·ªÉm: ${score}</span> &nbsp;|&nbsp; K·ª∑ l·ª•c: ${bestScore}<br/><br/>` +
                `<span style="font-size: 0.8em; font-weight: 500;'>B·∫•m <b>Space</b> ho·∫∑c <b>Click/Touch</b> ƒë·ªÉ ch∆°i l·∫°i</span>` + 
                settingsButtonHTML;
        } else {
            // playing
            centerText.innerHTML = "";
        }
    }


    function spawnPipe() {
      const minGapY = 80; 
      const maxGapY = height - 80 - gapHeight; 
      
      if (maxGapY <= minGapY) return; 

      const gapY = minGapY + Math.random() * (maxGapY - minGapY);

      pipes.push({
        x: width + 20,
        width: PIPE_WIDTH,
        gapY: gapY,
        gapHeight: gapHeight, // S·ª≠ d·ª•ng gapHeight ƒë·ªông
        passed: false
      });
    }

    function createExplosion(x, y) {
        const skin = SKINS[currentSkin];
        particles.length = 0;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({
                x: x,
                y: y,
                vx: Math.random() * 8 - 4, 
                vy: Math.random() * -10,    
                size: Math.random() * 4 + 2,
                // D√πng m√†u skin hi·ªán t·∫°i cho h·∫°t b·ª•i
                color: (i % 2 === 0) ? skin.body : skin.outline, 
                life: 500 + Math.random() * 500 
            });
        }
    }

    function update(delta) {
      const deltaFactor = delta / 16.67; 
      
      // Update hi·ªáu ·ª©ng rung m√†n h√¨nh
      if (shakeIntensity > 0) {
          shakeIntensity *= SHAKE_DECAY;
          if (shakeIntensity < 0.5) shakeIntensity = 0;
      }

      // Update h·∫°t b·ª•i
      for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx * deltaFactor;
          p.y += p.vy * deltaFactor;
          p.vy += 0.5 * deltaFactor; // Tr·ªçng l·ª±c t√°c ƒë·ªông l√™n h·∫°t
          p.life -= delta;
          if (p.life <= 0) {
              particles.splice(i, 1);
          }
      }

      if (gameState !== "playing") return;

      // --- DYNAMIC DIFFICULTY SCALING ---
      const newDifficultyLevel = Math.floor(score / DIFFICULTY_SCORE_STEP);
      if (newDifficultyLevel > difficultyLevel) {
          difficultyLevel = newDifficultyLevel;
          
          pipeSpeed = Math.min(BASE_PIPE_SPEED + difficultyLevel * 0.2, 4.0);
          gapHeight = Math.max(BASE_GAP_HEIGHT - difficultyLevel * 10, 100);
      }


      // Update chim
      birdVelocity += GRAVITY * deltaFactor;
      birdY += birdVelocity * deltaFactor;
      
      // Update timer ƒë·∫≠p c√°nh
      wingFlapTimer += delta * 0.01; 

      // C·∫≠p nh·∫≠t g√≥c quay c·ªßa chim
      const targetRotation = Math.min(Math.max(birdVelocity * 0.1, -MAX_ROTATION), MAX_ROTATION * 2);
      birdRotation = birdRotation + (targetRotation - birdRotation) * ROTATION_SPEED * deltaFactor;
      
      // T·∫Øt c·ªù isFlapping sau khi nh·∫£y
      if (isFlapping && deltaFactor > 0) {
        isFlapping = false;
      }

      // Chim ch·∫°m tr·∫ßn ho·∫∑c s√†n
      if (birdY - BIRD_RADIUS < 0 || birdY + BIRD_RADIUS > height) {
        if (birdY + BIRD_RADIUS > height) {
            birdRotation = MAX_ROTATION;
        }
        gameOver();
        return;
      }
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ Parallax (M√¢y)
      for (const cloud of clouds) {
        cloud.x -= pipeSpeed * cloud.speed * deltaFactor; 
        if (cloud.x + cloud.size < 0) {
          cloud.x = width + Math.random() * 100;
          cloud.y = 50 + Math.random() * (height / 3);
          cloud.size = 60 + Math.random() * 60;
        }
      }

      // Spawn ·ªëng m·ªõi
      pipeSpawnTimer += delta;
      if (pipeSpawnTimer >= PIPE_INTERVAL) {
        spawnPipe();
        pipeSpawnTimer = 0;
      }

      // Update ·ªëng
      for (let i = 0; i < pipes.length; i++) {
        const pipe = pipes[i];
        pipe.x -= pipeSpeed * deltaFactor; // S·ª≠ d·ª•ng pipeSpeed ƒë·ªông

        // T√≠nh ƒëi·ªÉm
        if (!pipe.passed && pipe.x + pipe.width < BIRD_X) {
          pipe.passed = true;
          score++;
          playScore(); // Ch∆°i √¢m thanh ghi ƒëi·ªÉm
        }
      }

      // X√≥a ·ªëng ƒë√£ ƒëi qua ho√†n to√†n
      for (let i = pipes.length - 1; i >= 0; i--) {
        if (pipes[i].x + pipes[i].width < 0) {
          pipes.splice(i, 1);
        }
      }

      // Ki·ªÉm tra va ch·∫°m
      for (const pipe of pipes) {
        const withinX =
          BIRD_X + BIRD_RADIUS > pipe.x &&
          BIRD_X - BIRD_RADIUS < pipe.x + pipe.width;

        if (withinX) {
          const inGap =
            birdY - BIRD_RADIUS > pipe.gapY &&
            birdY + BIRD_RADIUS < pipe.gapY + pipe.gapHeight;

          if (!inGap) {
            gameOver();
            return;
          }
        }
      }
    }

    // --- H√†m V·∫Ω Game (Draw) ---
    
    function drawParallax() {
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        for (const cloud of clouds) {
            ctx.beginPath();
            ctx.arc(cloud.x, cloud.y, cloud.size * 0.3, 0, Math.PI * 2);
            ctx.arc(cloud.x + cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
            ctx.arc(cloud.x - cloud.size * 0.3, cloud.y + cloud.size * 0.1, cloud.size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }
    }


    function drawBackground() {
      const theme = THEMES[currentTheme];
      
      // √Åp d·ª•ng background (B·∫ßu tr·ªùi)
      canvas.style.background = theme.skyGradient;

      drawParallax(); 

      const groundHeight = 80;
      ctx.fillStyle = theme.groundColor; 
      ctx.fillRect(0, height - groundHeight, width, groundHeight);

      ctx.fillStyle = theme.grassColor; 
      ctx.fillRect(0, height - groundHeight, width, 10);
    }

    function drawPipes() {
      const theme = THEMES[currentTheme];

      for (const pipe of pipes) {
        ctx.fillStyle = theme.pipeColor; 

        // ·ªêng tr√™n
        ctx.fillRect(pipe.x, 0, pipe.width, pipe.gapY);

        // ·ªêng d∆∞·ªõi
        ctx.fillRect(
          pipe.x,
          pipe.gapY + pipe.gapHeight,
          pipe.width,
          height - (pipe.gapY + pipe.gapHeight)
        );

        // Vi·ªÅn ·ªëng
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 3;
        ctx.strokeRect(pipe.x, 0, pipe.width, pipe.gapY);
        ctx.strokeRect(
          pipe.x,
          pipe.gapY + pipe.gapHeight,
          pipe.width,
          height - (pipe.gapY + pipe.gapHeight)
        );
        
        // V·∫Ω n·∫Øp ·ªëng
        ctx.fillStyle = theme.pipeCapColor; 
        const capHeight = 30;
        const capWidth = pipe.width * 1.1; 
        const capOffset = (capWidth - pipe.width) / 2;
        
        ctx.fillRect(pipe.x - capOffset, pipe.gapY - capHeight, capWidth, capHeight);
        ctx.fillRect(pipe.x - capOffset, pipe.gapY + pipe.gapHeight, capWidth, capHeight);
        
        // Vi·ªÅn n·∫Øp
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 3;
        ctx.strokeRect(pipe.x - capOffset, pipe.gapY - capHeight, capWidth, capHeight);
        ctx.strokeRect(pipe.x - capOffset, pipe.gapY + pipe.gapHeight, capWidth, capHeight);
      }
    }
    
    function drawWing(flapAngle, skin) {
        // V·∫Ω c√°nh (h√¨nh tam gi√°c)
        ctx.save();
        ctx.translate(-BIRD_RADIUS * 0.8, 0); // G·ªëc g·∫Øn c√°nh
        ctx.rotate(flapAngle);
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-12, -15); // C√°nh tr√™n
        ctx.lineTo(-12, 10);  // C√°nh d∆∞·ªõi
        ctx.closePath();
        ctx.fillStyle = skin.wing; // M√†u c√°nh theo skin
        ctx.fill();
        ctx.restore();
    }

    function drawBird() {
      const skin = SKINS[currentSkin];
      
      // B·∫Øt ƒë·∫ßu x·ª≠ l√Ω Rotation
      ctx.save();
      
      // Di chuy·ªÉn g·ªëc t·ªça ƒë·ªô v·ªÅ t√¢m chim
      ctx.translate(BIRD_X, birdY);
      // Xoay
      ctx.rotate(birdRotation);
      
      // T√≠nh to√°n g√≥c ƒë·∫≠p c√°nh (Sin wave)
      const autoFlapAngle = Math.sin(wingFlapTimer * FLAP_FREQUENCY) * FLAP_AMPLITUDE; 
      // Manual flap (ch·ªâ x·∫£y ra khi isFlapping == true)
      const manualFlap = isFlapping ? -MAX_ROTATION : 0; 

      // 0. V·∫Ω C√°nh
      drawWing(autoFlapAngle + manualFlap, skin);
      
      // 1. Th√¢n
      ctx.beginPath();
      ctx.arc(0, 0, BIRD_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = skin.body; // M√†u th√¢n theo skin
      ctx.fill();
      
      // Vi·ªÅn th√¢n
      ctx.strokeStyle = skin.outline; // M√†u vi·ªÅn theo skin
      ctx.lineWidth = 2;
      ctx.stroke();

      // 2. M·∫Øt (Ph·∫ßn tr·∫Øng)
      ctx.beginPath();
      ctx.arc(5, -4, 3, 0, Math.PI * 2);
      ctx.fillStyle = "#fff";
      ctx.fill();

      // 3. Con ng∆∞∆°i (Ph·∫ßn ƒëen)
      ctx.beginPath();
      ctx.arc(5, -4, 1.5, 0, Math.PI * 2);
      ctx.fillStyle = "#000";
      ctx.fill();

      // 4. M·ªè (M√†u cam, gi·ªØ nguy√™n)
      ctx.beginPath();
      ctx.moveTo(BIRD_RADIUS, 0);
      ctx.lineTo(BIRD_RADIUS + 8, 4);
      ctx.lineTo(BIRD_RADIUS + 8, -4);
      ctx.closePath();
      ctx.fillStyle = "#e67e22";
      ctx.fill();
      
      // K·∫øt th√∫c x·ª≠ l√Ω Rotation
      ctx.restore();
    }
    
    function drawParticles() {
        for (const p of particles) {
            ctx.fillStyle = p.color;
            // ƒê·ªô trong su·ªët gi·∫£m d·∫ßn theo th·ªùi gian s·ªëng
            ctx.globalAlpha = p.life / 1000; 
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1; // Reset alpha
    }


    function draw() {
      // √Åp d·ª•ng Screen Shake
      const shakeX = shakeIntensity > 0 ? (Math.random() * 2 - 1) * shakeIntensity : 0;
      const shakeY = shakeIntensity > 0 ? (Math.random() * 2 - 1) * shakeIntensity : 0;
      
      ctx.save();
      ctx.translate(shakeX, shakeY);
      
      // X√≥a to√†n b·ªô canvas ƒë·ªÉ v·∫Ω l·∫°i
      ctx.clearRect(0, 0, width, height);

      drawBackground();
      drawPipes();
      
      // Ch·ªâ v·∫Ω chim n·∫øu kh√¥ng ph·∫£i tr·∫°ng th√°i GAME OVER (ƒë√£ n·ªï th√†nh particles)
      if (gameState !== "gameOver" || particles.length === 0) {
        drawBird();
      }
      
      drawParticles(); // V·∫Ω h·∫°t b·ª•i

      // V·∫Ω ƒëi·ªÉm l·ªõn tr√™n canvas
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.font = "36px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(score, width / 2, 60);

      // C·∫≠p nh·∫≠t overlay
      scoreOverlay.textContent = `ƒêi·ªÉm: ${score} | K·ª∑ l·ª•c: ${bestScore} | ƒê·ªô kh√≥: ${difficultyLevel}`;
      
      ctx.restore(); // K·∫øt th√∫c Screen Shake
    }

    // --- V√≤ng l·∫∑p Game (requestAnimationFrame) ---

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      // Gi·ªõi h·∫°n delta time
      const limitedDelta = Math.min(delta, 1000 / 30); 

      update(limitedDelta);
      draw();

      requestAnimationFrame(loop);
    }

    // --- X·ª≠ l√Ω Input & Responsive ---
    
    function handleInput() {
      // Ch·ªâ nh·∫≠n input khi kh√¥ng ·ªü trong modal
      if (settingsModal.style.display === 'flex') return;
      
      if (gameState === "menu") {
        startGame();
      } else if (gameState === "playing") {
        birdVelocity = JUMP_STRENGTH;
        birdRotation = -MAX_ROTATION; 
        isFlapping = true; // K√≠ch ho·∫°t ƒë·∫≠p c√°nh th·ªß c√¥ng
        playJump(); // Ch∆°i √¢m thanh nh·∫£y
      } else if (gameState === "gameOver") {
        startGame();
      }
    }
    
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        width = container.clientWidth;
        height = container.clientHeight;
        
        canvas.width = width;
        canvas.height = height;
        
        const storedScore = localStorage.getItem('flappyBestScore');
        if (storedScore) {
            bestScore = parseInt(storedScore, 10);
        }
        
        // C·∫≠p nh·∫≠t background khi resize
        canvas.style.background = THEMES[currentTheme].skyGradient;
    }

    // Input: keyboard (Spacebar & Settings Shortcut)
    window.addEventListener("keydown", (e) => {
      // 1. Ph√≠m Space ƒë·ªÉ nh·∫£y/b·∫Øt ƒë·∫ßu
      if (e.code === "Space" || e.key === " ") {
        e.preventDefault();
        handleInput();
      } 
      
      // 2. Ph√≠m 'B' (B·∫≠t/T·∫Øt C√†i ƒë·∫∑t)
      else if (e.key.toLowerCase() === 'b') {
        // Ch·ªâ ho·∫°t ƒë·ªông khi kh√¥ng ƒëang ch∆°i
        if (gameState !== "playing") {
          e.preventDefault();
          if (settingsModal.style.display === 'flex') {
            closeSettingsModal();
          } else {
            openSettingsModal(e);
          }
        }
      }
    });

    // Input: mouse / touch
    canvas.addEventListener("mousedown", () => {
      handleInput();
    });
    
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleInput();
    }, { passive: false });
    
    window.addEventListener('resize', resizeCanvas);


    // --- Kh·ªüi t·∫°o v√† B·∫Øt ƒë·∫ßu ---
    initAudio(); // Kh·ªüi t·∫°o c√°c b·ªô t·ªïng h·ª£p √¢m thanh
    resizeCanvas();
    resetGame();
    renderSettings(); // Render UI ch·ªçn theme/skin
    updateUIState(); // Kh·ªüi t·∫°o tr·∫°ng th√°i UI ban ƒë·∫ßu
    requestAnimationFrame(loop);
  </script>
</body>
</html>